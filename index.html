/* ---------- Robust fixture extraction and rendering ---------- */
/* Call: const fixtureRows = extractFixtureRows(rows); renderFixtureList(fixtureRows); */

function extractFixtureRows(rows){
  // rows: array of arrays (CSV parsed)
  // returns array of rows: [[round, opponent, venue], ...]
  const out = [];

  // helper to normalize a cell
  const norm = (s)=> (s||'').toString().trim().toLowerCase();

  // 1) Try to find a header row that contains 'round' and 'opponent' (or 'fixture')
  let headerIdx = -1;
  for(let i=0;i<rows.length;i++){
    const row = rows[i].map(c=> norm(c));
    if(row.some(c=> c === 'fixture' || c.includes('fixture'))){
      headerIdx = i;
      break;
    }
    if(row.some(c=> c.indexOf('round') !== -1) && (row.some(c=> c.indexOf('opponent') !== -1) || row.some(c=> c.indexOf('fixture') !== -1))){
      headerIdx = i;
      break;
    }
  }

  // 2) If header found, detect which columns are Round / Opponent / Venue
  if(headerIdx >= 0){
    const headerRow = rows[headerIdx].map(c=> (c||'').toString().trim());
    const headerLow = headerRow.map(h=> norm(h));
    const roundCol = headerLow.findIndex(h=> h.includes('round') || h === '#' );
    const opponentCol = headerLow.findIndex(h=> h.includes('opponent') || h.includes('oppo') || h.includes('opponent/team') || h.includes('opponent name'));
    const venueColCandidates = ['venue','location','ground','court','arena'];
    let venueCol = -1;
    for(const v of venueColCandidates){
      const idx = headerLow.findIndex(h=> h.includes(v));
      if(idx !== -1){ venueCol = idx; break; }
    }

    // start reading rows after headerIdx
    for(let r = headerIdx+1; r < rows.length; r++){
      const line = rows[r];
      const joined = (line || []).join('').trim();
      if(!joined) break; // stop at first empty row
      // sanity check: if line seems to be player rows (contains 'pts' or many empty cells), skip
      const lowLine = line.map(c=> norm(c)).join(' ');
      if(lowLine.includes('player') && lowLine.includes('pts')) break;

      const roundVal = (roundCol >= 0 ? (line[roundCol]||'').toString().trim() : (line[0]||'').toString().trim());
      const opponentVal = (opponentCol >= 0 ? (line[opponentCol]||'').toString().trim() : (line[1]||'').toString().trim());
      const venueVal = (venueCol >= 0 ? (line[venueCol]||'').toString().trim() : (line[2]||'').toString().trim());

      // if row doesn't contain either round or opponent, treat as end of fixture block
      if(!(roundVal || opponentVal)) break;

      out.push([ roundVal || '', opponentVal || '', venueVal || '' ]);
    }
  }

  // 3) Fallback: sometimes the sheet lists fixtures in a fixed offset (e.g., lines 51..70)
  if(out.length === 0){
    // try to find a block where column 0 looks like "ROUND" or starts with a number 1..20 and col1 non-empty
    for(let start=0; start < rows.length - 2; start++){
      const a = (rows[start]||[])[0] || '';
      const b = (rows[start+1]||[])[0] || '';
      const c = (rows[start+2]||[])[0] || '';
      // look for a repeating pattern with numbers or 'ROUND' header
      if( (/^round/i.test(a) && rows[start+1] && (rows[start+1][1] || rows[start+1][2])) || (/^\d+$/.test((rows[start+1]||[])[0]) && (rows[start+1]||[])[1]) ){
        // collect several rows downward until blank
        for(let r = start+1; r < rows.length; r++){
          const joined = (rows[r]||[]).join('').trim();
          if(!joined) break;
          const roundVal = (rows[r][0]||'').toString().trim();
          const opponentVal = (rows[r][1]||'').toString().trim();
          const venueVal = (rows[r][2]||'').toString().trim();
          if(roundVal || opponentVal) out.push([roundVal, opponentVal, venueVal]);
        }
        if(out.length) break;
      }
    }
  }

  // 4) final tidy: normalize round labels like '1' -> 'ROUND 1' if necessary
  return out.map((r, i) => {
    let rr = r[0] ? r[0].toString().trim() : '';
    if(/^\d+$/.test(rr)) rr = 'ROUND ' + rr;
    if(/^round\s*\d+/i.test(rr) === false && rr === '') rr = 'ROUND ' + (i+1);
    return [ rr, r[1]||'TBD', r[2]||'Venue TBA' ];
  });
}

/* Example usage in your flow after you parse CSV into 'rows': 
   const fixtureRows = extractFixtureRows(rows);
   renderFixtureList(fixtureRows);
*/
